<!DOCTYPE html><html class="theme-next muse use-motion" lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><link rel="stylesheet" media="all" href="https://static.i7years.com/blog/lib/Han/dist/han.min.css?v=3.3"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://static.i7years.com/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="https://static.i7years.com/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="https://static.i7years.com/blog/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/favicon-180x180.png?v=5.1.3"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.3"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.3"><link rel="mask-icon" href="/logo.svg?v=5.1.3" color="#222"><meta name="keywords" content="Netty,"><meta name="description" content="前面，我们分析了Netty EventLoop的 创建 与 启动 原理，接下里我们来分析Netty中另外两个重要组件—— ChannelHandler 与 Pipeline。Netty中I/O事件的传播机制均由它负责，下面我们来看看它是如何实现的。"><meta name="keywords" content="Netty"><meta property="og:type" content="article"><meta property="og:title" content="Netty Pipeline源码分析(1)"><meta property="og:url" content="https://wangwei.one/posts/netty-pipeline-source-analyse-1.html"><meta property="og:site_name" content="终生学习"><meta property="og:description" content="前面，我们分析了Netty EventLoop的 创建 与 启动 原理，接下里我们来分析Netty中另外两个重要组件—— ChannelHandler 与 Pipeline。Netty中I/O事件的传播机制均由它负责，下面我们来看看它是如何实现的。"><meta property="og:locale" content="en"><meta property="og:image" content="https://img.i7years.com/netty/Channel%20lifecycle.png"><meta property="og:image" content="https://img.i7years.com/netty/ChannelHandlerUML.png"><meta property="og:image" content="https://img.i7years.com/netty/Channel-Pipeline.png"><meta property="og:image" content="https://img.i7years.com/netty/Channel%20Pipeline%20Event%20Flow.png"><meta property="og:image" content="https://img.i7years.com/netty/Netty%20Pipeline%20UML.png"><meta property="og:image" content="https://img.i7years.com/netty/Pipeline%20Init%20Ctx.png"><meta property="og:updated_time" content="2018-11-02T03:17:11.065Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Netty Pipeline源码分析(1)"><meta name="twitter:description" content="前面，我们分析了Netty EventLoop的 创建 与 启动 原理，接下里我们来分析Netty中另外两个重要组件—— ChannelHandler 与 Pipeline。Netty中I/O事件的传播机制均由它负责，下面我们来看看它是如何实现的。"><meta name="twitter:image" content="https://img.i7years.com/netty/Channel%20lifecycle.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.3",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://wangwei.one/posts/netty-pipeline-source-analyse-1.html"><title>Netty Pipeline源码分析(1) | 终生学习</title><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-112239883-1","auto"),ga("send","pageview")</script><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?7a23039be1256cfe778d1eeb19110f89";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="stylesheet" href="/lib/canvas-nest/css/particles-style.min.css"></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><div id="particles-js"></div><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">终生学习</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">每天夜里睡觉时都比那天早晨聪明一点点</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-区块链"><a href="/categories/blockchain/" rel="section"><i class="menu-item-icon fa fa-fw fa-btc"></i><br>区块链</a></li><li class="menu-item menu-item-编程"><a href="/categories/coding/" rel="section"><i class="menu-item-icon fa fa-fw fa-terminal"></i><br>编程</a></li><li class="menu-item menu-item-工具"><a href="/categories/tools/" rel="section"><i class="menu-item-icon fa fa-fw fa-gear"></i><br>工具</a></li><li class="menu-item menu-item-阅读"><a href="/books/" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i><br>阅读</a></li><li class="menu-item menu-item-原则"><a href="/principle/" rel="section"><i class="menu-item-icon fa fa-fw fa-road"></i><br>原则</a></li><li class="menu-item menu-item-电影"><a href="/movies/" rel="section"><i class="menu-item-icon fa fa-fw fa-film"></i><br>电影</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-关于"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://wangwei.one/posts/netty-pipeline-source-analyse-1.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="王维 / Michael  Wang"><meta itemprop="description" content=""><meta itemprop="image" content="https://img.i7years.com/avatar/naruto.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="终生学习"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Netty Pipeline源码分析(1)</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-14T14:32:00+08:00">2017-05-14 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/coding/" itemprop="url" rel="index"><span itemprop="name">coding</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/posts/netty-pipeline-source-analyse-1.html#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/netty-pipeline-source-analyse-1.html" itemprop="commentCount"></span></a></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Words count in article&#58;</span> <span title="Words count in article">5,271 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">26</span></div></div></header><div class="post-body han-init-context" itemprop="articleBody"><script src="/assets/js/APlayer.min.js"></script><p>前面，我们分析了Netty EventLoop的 <a href="https://wangwei.one/posts/netty-nioeventloop-analyse-for-create.html">创建</a> 与 <a href="https://wangwei.one/posts/netty-nioeventloop-analyse-for-startup.html">启动</a> 原理，接下里我们来分析Netty中另外两个重要组件—— <strong><a href="https://netty.io/4.1/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener"><em>ChannelHandler</em></a></strong> 与 <strong><a href="https://netty.io/4.1/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="noopener"><em>Pipeline</em></a></strong>。Netty中I/O事件的传播机制均由它负责，下面我们来看看它是如何实现的。</p><a id="more"></a><blockquote><p>Netty版本：4.1.30</p></blockquote><p>我们前面在讲 <a href="https://wangwei.one/posts/netty-channel-source-analyse.html">Channel创建</a> 时，在AbstractChannel的构造函数中， 一笔带过地提到了Pipeline，现在我们来深入分析一下它的原理。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Netty-channel-lifecycle"><a href="#Netty-channel-lifecycle" class="headerlink" title="Netty channel lifecycle"></a>Netty channel lifecycle</h3><p>前面，我们在分析 <a href="https://wangwei.one/posts/netty-channel-source-analyse.html">Netty channel</a> 源码时，分析了Channel的创建、初始化、注册、绑定过程。在Netty中，channel的生命周期如下所示：</p><p><img src="https://img.i7years.com/netty/Channel%20lifecycle.png" alt="Channel lifecycle"></p><ul><li>ChannelRegistered：Channel注册到了EventLoop上</li><li>ChannelActive：Channel激活，连接到了远程某一个节点上，可以收发数据了</li><li>ChannelInactive：断开连接</li><li>ChannelUnregistered：Channel从EventLoop上取消注册</li></ul><h3 id="Netty-channelHandler"><a href="#Netty-channelHandler" class="headerlink" title="Netty channelHandler"></a>Netty channelHandler</h3><p>Channel 每一次状态的变化，都会产生一个对应的事件，并且都会触发 <a href="https://netty.io/4.1/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener"><strong><em>ChannelHandler</em></strong></a> 中对应的方法进行处理，例如，当一个Channel成功注册到EventLoop上后，会有触发channelHanndler中的handlerRegistered(…) 来处理该事件。</p><p><img src="https://img.i7years.com/netty/ChannelHandlerUML.png" alt="ChannelHandlerUML"></p><p>在上面的 ChannelHandler UML中，最为重要的两个ChannelHandler：</p><ul><li><a href="https://netty.io/4.1/api/io/netty/channel/ChannelInboundHandler.html" target="_blank" rel="noopener">ChannelInboundHandler</a>：处理入站数据以及channel的各种状态变化</li><li><a href="https://netty.io/4.1/api/io/netty/channel/ChannelOutboundHandler.html" target="_blank" rel="noopener">ChannelOutboundHandler</a>：处理出站数据并允许拦截所有操作</li></ul><h3 id="Netty-ChannelPipeline"><a href="#Netty-ChannelPipeline" class="headerlink" title="Netty ChannelPipeline"></a>Netty ChannelPipeline</h3><p>前面我们在分析Channel创建过程时，每一个新创建的Channel都将会被分配一个新的ChannelPipeline。ChannelPipeline是一个拦截流经Channel的入站和出站事件的ChannelHandler实例链，如图所示：</p><p><img src="https://img.i7years.com/netty/Channel-Pipeline.png" alt="Channel-Pipeline"></p><p>一个 Channel 包含了一个 ChannelPipeline，ChannelPipeline内部是一个双向的链表结构，内部由一个个的ChannelHandlerContext节点组成，ChannelPipeline有头尾两个固定的节点HeadContext与TailContext。用户自定的ChannelHandler就是由ChannelHandlerContext包装成Pipeline的节点，参与Channel整个生命周期中所触发的入站事件与出站事件以及相应数据流的拦截处理。</p><p>根据事件的起源，事件将会被ChannelInboundHandler(入站处理器)或者ChannelOutboundHandler(出站处理器)处理。随后，通过调用ChannelHandlerContext实现，它将被转发给同一超类型的下一个ChannelHandler，如图所示：</p><p><img src="https://img.i7years.com/netty/Channel%20Pipeline%20Event%20Flow.png" alt="Channel Pipeline Event Flow"></p><h2 id="Pipeline-UML"><a href="#Pipeline-UML" class="headerlink" title="Pipeline UML"></a>Pipeline UML</h2><p>我们先来看下 <em>ChannelPipeline</em> 以及 <em>ChannelHandlerContext</em> 的类图结构，它们都实现了<em>ChannelInboundInvoker</em>与<em>ChannelOutboundInvoker</em>接口。</p><p><img src="https://img.i7years.com/netty/Netty%20Pipeline%20UML.png" alt="Netty Pipeline UML"></p><h2 id="Pipeline初始化"><a href="#Pipeline初始化" class="headerlink" title="Pipeline初始化"></a>Pipeline初始化</h2><p>AbstractChannel构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    <span class="comment">// 创建默认Pipeline</span></span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建默认Pipeline</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultChannelPipeline 构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置尾部节点</span></span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 设置头部节点</span></span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将tail与head串联起来</span></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到Pipeline其实是一个双向链表的结构，刚刚初始化的时候，Pipeline(管道)中只有两个节点，如图：</p><p><img src="https://img.i7years.com/netty/Pipeline%20Init%20Ctx.png" alt="Pipeline Init Ctx"></p><p>接下来我们看看组成Pipeline节点的对象—— ChannelHandlerContext。</p><h3 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h3><p>ChannelHandlerContext 实现了AttributeMap、ChannelInboundInvoker、ChannelOutboundInvoker接口。Pipeline中的事件传播，都是由ChannelHandlerContext负责，将发生的事件从一个节点传到下一个节点。</p><h4 id="ChannelHandlerContext接口"><a href="#ChannelHandlerContext接口" class="headerlink" title="ChannelHandlerContext接口"></a>ChannelHandlerContext接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandlerContext</span> <span class="keyword">extends</span> <span class="title">AttributeMap</span>, <span class="title">ChannelInboundInvoker</span>, <span class="title">ChannelOutboundInvoker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回ChannelHandlerContext中绑定的Channel</span></span><br><span class="line">    <span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回专用于执行任务的 EventExecutor</span></span><br><span class="line">    <span class="function">EventExecutor <span class="title">executor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回ChannelHandlerContext的唯一名称。该名字将在ChannelHandler被添加到ChannelPipeline时会被用到，从ChannelPipeline中访问注册的ChannelHandler时，也会被用到。</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回ChannelHandlerContext中绑定的ChannelHandler</span></span><br><span class="line">    <span class="function">ChannelHandler <span class="title">handler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属于这个ChannelHandlerContext的ChannelHandler从ChannelPipeline移除了，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRemoved</span><span class="params">()</span></span>;</span><br><span class="line">		</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelHandlerContext <span class="title">fireChannelRegistered</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelHandlerContext <span class="title">fireChannelUnregistered</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelHandlerContext <span class="title">fireChannelActive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelHandlerContext <span class="title">fireChannelInactive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelHandlerContext <span class="title">fireExceptionCaught</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelHandlerContext <span class="title">fireUserEventTriggered</span><span class="params">(Object evt)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(Object msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelHandlerContext <span class="title">fireChannelReadComplete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelHandlerContext <span class="title">fireChannelWritabilityChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelHandlerContext <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelHandlerContext <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回分配的ChannelPipeline</span></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">pipeline</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用于分配ByteBuf的ByteBufAllocator</span></span><br><span class="line">    <span class="function">ByteBufAllocator <span class="title">alloc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AttributeMap接口"><a href="#AttributeMap接口" class="headerlink" title="AttributeMap接口"></a>AttributeMap接口</h4><p>实现 AttributeMap 接口，表示ChannelHandlerContext节点可以存储自定义的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性Map接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AttributeMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过Key获取属性</span></span><br><span class="line">    &lt;T&gt; <span class="function">Attribute&lt;T&gt; <span class="title">attr</span><span class="params">(AttributeKey&lt;T&gt; key)</span></span>;</span><br><span class="line">	<span class="comment">// 判断属性是否存在</span></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">hasAttr</span><span class="params">(AttributeKey&lt;T&gt; key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ChannelInboundInvoker接口"><a href="#ChannelInboundInvoker接口" class="headerlink" title="ChannelInboundInvoker接口"></a>ChannelInboundInvoker接口</h4><p>实现ChannelInboundInvoker接口，表示节点可以用于传播入站相关的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelInboundInvoker</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当Channel注册到EventLoop上时</span></span><br><span class="line">	<span class="comment">// 调用ChannelPipeline中下一个ChannelInboundHandler的channelRegistered(ChannelHandlerContext)方法 </span></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireChannelRegistered</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 当Channel从EventLoop上取消注册</span></span><br><span class="line">    <span class="comment">// 调用ChannelPipeline中下一个ChannelInboundHandler的channelUnregistered(ChannelHandlerContext)方法 </span></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireChannelUnregistered</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 当Channel处理激活状态，意味着连接已经建立</span></span><br><span class="line">    <span class="comment">// 调用ChannelPipeline中下一个ChannelInboundHandler的channelActive(ChannelHandlerContext)方法 </span></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireChannelActive</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当Channel处理失效状态，意味着连接已经断开</span></span><br><span class="line">	<span class="comment">// 调用ChannelPipeline中下一个ChannelInboundHandler的channelInactive(ChannelHandlerContext)方法 </span></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireChannelInactive</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在pipeline中某个一个入站(inbound)操作出现了异常</span></span><br><span class="line">	<span class="comment">// 调用ChannelPipeline中下一个ChannelInboundHandler的exceptionCaught(ChannelHandlerContext)方法 </span></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireExceptionCaught</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 收到用户自定义的事件</span></span><br><span class="line">	<span class="comment">// 调用ChannelPipeline中下一个ChannelInboundHandler的userEventTriggered(ChannelHandlerContext)方法</span></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireUserEventTriggered</span><span class="params">(Object event)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Channel接收到了消息</span></span><br><span class="line">	<span class="comment">// 调用ChannelPipeline中下一个ChannelInboundHandler的channelRead(ChannelHandlerContext)方法</span></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireChannelRead</span><span class="params">(Object msg)</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 调用ChannelPipeline中下一个ChannelInboundHandler的channelReadComplete(ChannelHandlerContext)方法</span></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireChannelReadComplete</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 调用ChannelPipeline中下一个ChannelInboundHandler的channelWritabilityChanged(ChannelHandlerContext)方法</span></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireChannelWritabilityChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ChannelOutboundInvoker接口"><a href="#ChannelOutboundInvoker接口" class="headerlink" title="ChannelOutboundInvoker接口"></a>ChannelOutboundInvoker接口</h4><p>实现ChannelOutboundInvoker接口，意味着节点可以用来处理出站相关的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelOutboundInvoker</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将Channel绑定到一个本地地址，这将调用ChannelPipeline中的下一个ChannelOutboundHandler的bind(ChannelHandlerContext, Socket- Address, ChannelPromise)方法</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span></span>;</span><br><span class="line">	<span class="function">ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Channel连接到一个远程地址，这将调用ChannelPipeline中的下一个ChannelOutboundHandler的connect(ChannelHandlerContext, Socket- Address, ChannelPromise)方法</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span></span>;</span><br><span class="line">	<span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Channel断开连接。这将调用ChannelPipeline中的下一个ChannelOutbound- Handler的disconnect(ChannelHandlerContext, Channel Promise)方法</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">disconnect</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 将Channel关闭。这将调用ChannelPipeline中的下一个ChannelOutbound- Handler的close(ChannelHandlerContext, ChannelPromise)方法</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">close</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Channel从它先前所分配的EventExecutor（即EventLoop）中注销。这将调用ChannelPipeline中的下一个ChannelOutboundHandler的deregister (ChannelHandlerContext, ChannelPromise)方法</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">deregister</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">deregister</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 请求从Channel中读取更多的数据。这将调用ChannelPipeline中的下一个ChannelOutboundHandler的read(ChannelHandlerContext)方法</span></span><br><span class="line">    <span class="function">ChannelOutboundInvoker <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将消息写入Channel。这将调用ChannelPipeline中的下一个Channel- OutboundHandler的write(ChannelHandlerContext, Object msg, Channel- Promise)方法。注意：这并不会将消息写入底层的Socket，而只会将它放入队列中。要将它写入Socket，需要调用flush()或者writeAndFlush()方法 </span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span></span>;</span><br><span class="line">	</span><br><span class="line">   <span class="comment">// 冲刷Channel所有挂起的写入。这将调用ChannelPipeline中的下一个Channel- OutboundHandler的flush(ChannelHandlerContext)方法</span></span><br><span class="line">    <span class="function">ChannelOutboundInvoker <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 这是一个先调用write()方法再接着调用flush()方法的便利方法</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelPromise <span class="title">newPromise</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelProgressivePromise <span class="title">newProgressivePromise</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">newSucceededFuture</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">newFailedFuture</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelPromise <span class="title">voidPromise</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TailContext-amp-HeadContext"><a href="#TailContext-amp-HeadContext" class="headerlink" title="TailContext &amp; HeadContext"></a>TailContext &amp; HeadContext</h3><p>接下来，我们看看Pipeline中的头部与尾部节点。</p><h4 id="TailContext节点"><a href="#TailContext节点" class="headerlink" title="TailContext节点"></a>TailContext节点</h4><p>TailContext是尾部节点，inbound类型，主要处理Pipeline中数据流的收尾工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TailContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span> <span class="keyword">implements</span> <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    TailContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">        <span class="comment">// 调用AbstractChannelHandlerContext构造器</span></span><br><span class="line">        <span class="comment">// TailContext是一个inbound(入站)节点</span></span><br><span class="line">        <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, TAIL_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 设置添加完成</span></span><br><span class="line">        setAddComplete();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 返回Handler，就是它自身</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        onUnhandledInboundException(cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        onUnhandledInboundMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果pipeline中有异常没做处理，最终会由TailContext打赢一个警告日志</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.warn(</span><br><span class="line">            <span class="string">"An exceptionCaught() event was fired, and it reached at the tail of the pipeline. "</span> +</span><br><span class="line">            <span class="string">"It usually means the last handler in the pipeline did not handle the exception."</span>,</span><br><span class="line">            cause);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放对象</span></span><br><span class="line">        ReferenceCountUtil.release(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果pipeline中有read消息没有处理，最终会由TailContext打赢一个警告日志</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.debug(</span><br><span class="line">            <span class="string">"Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. "</span> +</span><br><span class="line">            <span class="string">"Please check your pipeline configuration."</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 ChannelHandlerContext 状态为添加完成，状态=2</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAddComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldState = handlerState;</span><br><span class="line">        <span class="keyword">if</span> (oldState == REMOVE_COMPLETE || HANDLER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, oldState, ADD_COMPLETE)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">       	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AbstractChannelHandlerContext"><a href="#AbstractChannelHandlerContext" class="headerlink" title="AbstractChannelHandlerContext"></a>AbstractChannelHandlerContext</h4><p>AbstractChannelHandlerContext 是 ChannelHandlerContext 的抽象实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannelHandlerContext</span> <span class="keyword">extends</span> <span class="title">DefaultAttributeMap</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ChannelHandlerContext</span>, <span class="title">ResourceLeakHint</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> AbstractChannelHandlerContext next;</span><br><span class="line">    <span class="comment">// 上一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> AbstractChannelHandlerContext prev;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 是否为inBound类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> inbound;</span><br><span class="line">    <span class="comment">// 是否为outbound类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> outbound;</span><br><span class="line">    <span class="comment">// 绑定的默认pipeline</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultChannelPipeline pipeline;</span><br><span class="line">    <span class="comment">// 节点名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ordered;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Will be set to null if no child executor should be used, otherwise it will be set to the</span></span><br><span class="line">    <span class="comment">// child executor.</span></span><br><span class="line">    <span class="keyword">final</span> EventExecutor executor;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name,<span class="keyword">boolean</span> inbound, <span class="keyword">boolean</span> outbound) &#123;</span><br><span class="line">        <span class="comment">// 设置HandlerContext名称</span></span><br><span class="line">        <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">"name"</span>);</span><br><span class="line">        <span class="comment">// 绑定pipeline</span></span><br><span class="line">        <span class="keyword">this</span>.pipeline = pipeline;</span><br><span class="line">        <span class="comment">// 绑定executor(这里为null)</span></span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">        <span class="comment">// 如果节点为inbound类型就设置为true</span></span><br><span class="line">        <span class="keyword">this</span>.inbound = inbound;</span><br><span class="line">        <span class="comment">// 如果节点为outbound类型就设置为true</span></span><br><span class="line">        <span class="keyword">this</span>.outbound = outbound;</span><br><span class="line">        <span class="comment">// Its ordered if its driven by the EventLoop or the given Executor is an instanceof OrderedEventExecutor.</span></span><br><span class="line">        ordered = executor == <span class="keyword">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DefaultChannelHandlerContext"><a href="#DefaultChannelHandlerContext" class="headerlink" title="DefaultChannelHandlerContext"></a>DefaultChannelHandlerContext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelHandlerContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line">	</span><br><span class="line">    DefaultChannelHandlerContext(</span><br><span class="line">            DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) &#123;</span><br><span class="line">        <span class="comment">// 调用 AbstractChannelHandlerContext 构造函数</span></span><br><span class="line">        <span class="keyword">super</span>(pipeline, executor, name, isInbound(handler), isOutbound(handler));</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"handler"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否为inBound类型</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isInbound</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> ChannelInboundHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否为outBound类型</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOutbound</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> ChannelOutboundHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HeadContext"><a href="#HeadContext" class="headerlink" title="HeadContext"></a>HeadContext</h4><p>HeadContext是头部节点，outbound类型，用于传播事件和进行一些底层socket操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span>, <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line">	</span><br><span class="line">    HeadContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">		<span class="comment">// 调用AbstractChannelHandlerContext构造器</span></span><br><span class="line">		<span class="comment">// HeadContext是一个outbound(出站)节点</span></span><br><span class="line">        <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, HEAD_NAME, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 设置Unsafe对象</span></span><br><span class="line">        unsafe = pipeline.channel().unsafe();</span><br><span class="line">        <span class="comment">// 设置添加完成</span></span><br><span class="line">        setAddComplete();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回ChannelHandler，就只它自身</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 unsafe 进行bind操作    </span></span><br><span class="line">        unsafe.bind(localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">            SocketAddress remoteAddress, SocketAddress localAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">            ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 unsafe 进行 connect 操作</span></span><br><span class="line">        unsafe.connect(remoteAddress, localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 调用 unsafe 进行 disconnect 操作</span></span><br><span class="line">        unsafe.disconnect(promise);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 调用 unsafe 进行 close 操作</span></span><br><span class="line">        unsafe.close(promise);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 调用 unsafe 进行 deregister 操作</span></span><br><span class="line">        unsafe.deregister(promise);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">  	  <span class="comment">// 调用 unsafe 进行 read 操作</span></span><br><span class="line">        unsafe.beginRead();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 调用 unsafe 进行 write 操作</span></span><br><span class="line">        unsafe.write(msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 调用 unsafe 进行 flush 操作</span></span><br><span class="line">        unsafe.flush();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 传播ExceptionCaught事件</span></span><br><span class="line">        ctx.fireExceptionCaught(cause);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        invokeHandlerAddedIfNeeded();</span><br><span class="line">        <span class="comment">// 传播channelRegistered事件</span></span><br><span class="line">        ctx.fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 传播channelUnregistered事件</span></span><br><span class="line">        ctx.fireChannelUnregistered();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove all handlers sequentially if channel is closed and unregistered.</span></span><br><span class="line">        <span class="keyword">if</span> (!channel.isOpen()) &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 传播 channelActive 事件</span></span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">		<span class="comment">// 在 https://wangwei.one/posts/netty-channel-source-analyse.html 中分析过了</span></span><br><span class="line">		<span class="comment">// 主要是在channel激活之后，向底层的selector注册一个SelectionKey.OP_ACCEPT监听事件</span></span><br><span class="line">		<span class="comment">// 这样channel在连接之后，就可以监听到一个read事件</span></span><br><span class="line">        readIfIsAutoRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 传播 channelInactive 事件</span></span><br><span class="line">        ctx.fireChannelInactive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 传播 channelRead 事件</span></span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 传播 channelReadComplete 事件</span></span><br><span class="line">        ctx.fireChannelReadComplete();</span><br><span class="line">		<span class="comment">// </span></span><br><span class="line">        readIfIsAutoRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</span><br><span class="line">            channel.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 传播 userEventTriggered 事件</span></span><br><span class="line">        ctx.fireUserEventTriggered(evt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 传播 channelWritabilityChanged 事件</span></span><br><span class="line">        ctx.fireChannelWritabilityChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pipeline-节点添加"><a href="#Pipeline-节点添加" class="headerlink" title="Pipeline 节点添加"></a>Pipeline 节点添加</h2><p>上面我们分析了Pipeline的基本结构，接下来我们看看Pipeline添加节点（也就是Handler处理器）的过程。该过程主要分为三步：</p><ul><li>判断是否重复添加</li><li>创建节点并添加至链表</li><li>回调添加完成事件</li></ul><p>以这段常见的代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">b.group(group)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">        .option(ChannelOption.SO_KEEPALIVE, Boolean.TRUE)</span><br><span class="line">        .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>)</span><br><span class="line">        .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 添加 serverHandler</span></span><br><span class="line">                ch.pipeline().addLast(serverHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">ChannelFuture f = b.bind().sync();</span><br></pre></td></tr></table></figure><p>我们从 <strong>ChannelPipeline.addLast()</strong> 方法进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addLast(<span class="keyword">null</span>, handlers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"handlers"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环处理</span></span><br><span class="line">        <span class="keyword">for</span> (ChannelHandler h: handlers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            addLast(executor, <span class="keyword">null</span>, h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查是否重复</span></span><br><span class="line">            checkMultiplicity(handler);</span><br><span class="line">            <span class="comment">// 创建新节点</span></span><br><span class="line">            newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">            <span class="comment">// 添加新节点</span></span><br><span class="line">            addLast0(newCtx);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 registered 为 false,则表示这个channel还未注册到EventLoop上.</span></span><br><span class="line">            <span class="comment">// 在这种情况下，我们添加一个Task到PendingHandlerCallback中，</span></span><br><span class="line">            <span class="comment">// 等到这个channel注册成功之后，将会调用立即调用 ChannelHandler.handlerAdded(...) 方法，已达到channel添加的目的</span></span><br><span class="line">            <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">                <span class="comment">// 设置为待添加状态</span></span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 获取executor</span></span><br><span class="line">            EventExecutor executor = newCtx.executor();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">                <span class="comment">// 设置为待添加状态</span></span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 回调添加完成事件</span></span><br><span class="line">                        callHandlerAdded0(newCtx);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回调添加完成事件</span></span><br><span class="line">        callHandlerAdded0(newCtx);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否重复</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMultiplicity</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// handler是否为ChannelHandlerAdapter类型，不是则不做处理</span></span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ChannelHandlerAdapter) &#123;</span><br><span class="line">            ChannelHandlerAdapter h = (ChannelHandlerAdapter) handler;</span><br><span class="line">            <span class="comment">// 判断handler是否添加了Sharable注解 &amp;&amp; 是否添加过了</span></span><br><span class="line">            <span class="keyword">if</span> (!h.isSharable() &amp;&amp; h.added) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ChannelPipelineException(</span><br><span class="line">                    h.getClass().getName() +</span><br><span class="line">                    <span class="string">" is not a @Sharable handler, so can't be added or removed multiple times."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            h.added = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">newContext</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用DefaultChannelHandlerContext的构造函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelHandlerContext(<span class="keyword">this</span>, childExecutor(group), name, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在tail节点之前添加新节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext prev = tail.prev;</span><br><span class="line">        newCtx.prev = prev;</span><br><span class="line">        newCtx.next = tail;</span><br><span class="line">        prev.next = newCtx;</span><br><span class="line">        tail.prev = newCtx;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 回调ChannelHandler中的handlerAdded方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerAdded0</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 我们必须在handlerAdded方法之前调用setAddComplete方法。否则的话，一旦handlerAdded方法产生了任何pipeline事件，由于状态的缘故，ctx.handler()将会丢失这些事件的处理。</span></span><br><span class="line">            <span class="comment">// 设置新节点的状态为添加完成状态</span></span><br><span class="line">            ctx.setAddComplete();</span><br><span class="line">            <span class="comment">// 调用handlerAdded接口</span></span><br><span class="line">            ctx.handler().handlerAdded(ctx);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 如果添加失败，则删除新节点    </span></span><br><span class="line">            remove0(ctx);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看下setAddComplete()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannelHandlerContext</span> <span class="keyword">extends</span> <span class="title">DefaultAttributeMap</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ChannelHandlerContext</span>, <span class="title">ResourceLeakHint</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 通过自旋操作，设置状态为ADD_COMPLETE</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAddComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> oldState = handlerState;</span><br><span class="line">            <span class="comment">// Ensure we never update when the handlerState is REMOVE_COMPLETE already.</span></span><br><span class="line">            <span class="comment">// oldState is usually ADD_PENDING but can also be REMOVE_COMPLETE when an EventExecutor is used that is not</span></span><br><span class="line">            <span class="comment">// exposing ordering guarantees.</span></span><br><span class="line">            <span class="keyword">if</span> (oldState == REMOVE_COMPLETE || HANDLER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, oldState, ADD_COMPLETE)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置为 ADD_PENDING 状态</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAddPending</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> updated = HANDLER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, INIT, ADD_PENDING);</span><br><span class="line">        <span class="keyword">assert</span> updated; </span><br><span class="line">        <span class="comment">// This should always be true as it MUST be called before setAddComplete() or setRemoved().</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调用户自定义Handler中的handlerAdded方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">	   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"ServerHandler added ...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> 	...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ChannelInitializer"><a href="#ChannelInitializer" class="headerlink" title="ChannelInitializer"></a>ChannelInitializer</h3><p>关于回调ChannelHandler中的handlerAdded()方法，最常见的一个场景就是，使用 ChannelInitializer 来添加我们自定义的ChannelHandler。ChannelInitializer被添加完成之后，会回调到它的 initChannel 方法。</p><p>接下来，我们看看 <strong><em>ChannelInitializer</em></strong> 这个类，它是一个特殊的ChannelInboundHandler，它提供了一种在Channel注册到EventLoop后初始化Channel的简便方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;ChannelHandlerContext, Boolean&gt; initMap = PlatformDependent.newConcurrentHashMap();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当 ch 注册成功之后，该方法就会被调用，该方法结束返回之后，此ChannelInitializer实例将会从Channel所绑定的ChannelPipeline中移除</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ch 所注册的Channel</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(C ch)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// ChannelInitializer 添加成功后，会回调到handlerAdded()接口</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">            <span class="comment">// This should always be true with our current DefaultChannelPipeline implementation.</span></span><br><span class="line">            <span class="comment">// The good thing about calling initChannel(...) in handlerAdded(...) is that there will be no ordering</span></span><br><span class="line">            <span class="comment">// surprises if a ChannelInitializer will add another ChannelInitializer. This is as all handlers</span></span><br><span class="line">            <span class="comment">// will be added in the expected order.</span></span><br><span class="line">            initChannel(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 标记ctx为true,且之前没有标记过。防止重复执行</span></span><br><span class="line">        <span class="keyword">if</span> (initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用initChannel方法</span></span><br><span class="line">                initChannel((C) ctx.channel());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">                <span class="comment">// Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</span></span><br><span class="line">                <span class="comment">// We do so to prevent multiple calls to initChannel(...).</span></span><br><span class="line">                exceptionCaught(ctx, cause);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 最终会删除 ChannelInitializer 实例</span></span><br><span class="line">                remove(ctx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除 ChannelInitializer 实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 Pipeline</span></span><br><span class="line">            ChannelPipeline pipeline = ctx.pipeline();</span><br><span class="line">            <span class="comment">// 从 Pipeline 中返回 ChannelInitializer 实例</span></span><br><span class="line">            <span class="keyword">if</span> (pipeline.context(<span class="keyword">this</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 删除 ChannelInitializer 实例</span></span><br><span class="line">                <span class="comment">// 删除逻辑请看下一小节</span></span><br><span class="line">                pipeline.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            initMap.remove(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历 ChannelHandlerContext 节点查询出ChannelHandler实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过handler获取ChannelHandlerContext</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelHandlerContext <span class="title">context</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"handler"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">        AbstractChannelHandlerContext ctx = head.next;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ctx == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ctx.handler() == handler) &#123;</span><br><span class="line">                <span class="keyword">return</span> ctx;</span><br><span class="line">            &#125;</span><br><span class="line">            ctx = ctx.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pipeline中除了addLast方法外， 还有addFirst、addBefore、addAfter等方法，逻辑类似，可以自行研究学习。</p><h2 id="Pipeline-节点删除"><a href="#Pipeline-节点删除" class="headerlink" title="Pipeline 节点删除"></a>Pipeline 节点删除</h2><p>上面，我们讲了Pipeline节点的添加，这小结我们看看Pipeline节点的删除功能。</p><p>netty 有个最大的特性之一就是Handler可插拔，做到动态编织pipeline，比如在首次建立连接的时候，需要通过进行权限认证，在认证通过之后，就可以将此context移除，下次pipeline在传播事件的时候就就不会调用到权限认证处理器。</p><p>下面是权限认证Handler最简单的实现，第一个数据包传来的是认证信息，如果校验通过，就删除此Handler，否则，直接关闭连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鉴权Handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (verify(authDataPacket)) &#123;</span><br><span class="line">            ctx.pipeline().remove(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(ByteBuf byteBuf)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AuthHandler has been removed ! "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看 DefaultChannelPipeline 中的 remove 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 从Pipeline中删除ChannelHandler</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">remove</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        remove(getContextOrDie(handler));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 获取 ChannelHandler ，获取不到就抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">getContextOrDie</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) context(handler);</span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(handler.getClass().getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">remove</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ctx不能为heand与tail</span></span><br><span class="line">        <span class="keyword">assert</span> ctx != head &amp;&amp; ctx != tail;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 从pipeline中删除ChannelHandlerContext节点</span></span><br><span class="line">            remove0(ctx);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果为false，则表明channel还没有注册到eventloop上</span></span><br><span class="line">            <span class="comment">// 在删除这种场景下，我们先添加一个Task，一旦channel注册成功就会调用这个Task，这个Task就会立即调用ChannelHandler.handlerRemoved(...)方法，来从pipeline中删除context。</span></span><br><span class="line">            <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">                callHandlerCallbackLater(ctx, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">return</span> ctx;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EventExecutor executor = ctx.executor();</span><br><span class="line">            <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">                executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 回调 handlerRemoved 方法</span></span><br><span class="line">                        callHandlerRemoved0(ctx);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> ctx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回调 handlerRemoved 方法</span></span><br><span class="line">        callHandlerRemoved0(ctx);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> 	...</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 删除节点 ChannelHandlerContext</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove0</span><span class="params">(AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext prev = ctx.prev;</span><br><span class="line">        AbstractChannelHandlerContext next = ctx.next;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerRemoved0</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Notify the complete removal.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 回调 handlerRemoved 方法</span></span><br><span class="line">                <span class="comment">// 也就是我们前面例子 AuthHandler 中的 handlerRemoved() 方法</span></span><br><span class="line">                ctx.handler().handlerRemoved(ctx);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 设置为ctx 状态为 REMOVE_COMPLETE </span></span><br><span class="line">                ctx.setRemoved();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            fireExceptionCaught(<span class="keyword">new</span> ChannelPipelineException(</span><br><span class="line">                    ctx.handler().getClass().getName() + <span class="string">".handlerRemoved() has thrown an exception."</span>, t));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了， 删除的逻辑就分析到这里了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一讲我们分析了Pipeline的创建过程，了解Pipeline中的链表结构以及每个节点的数据结构。还分析了Pipeline是如何添加节点的，又是如何删除节点的。<a href="https://wangwei.one/posts/netty-pipeline-source-analyse-2.html">接下来</a> ，我们会分析Pipeline如何进行事件传播的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://coding.imooc.com/class/230.html" target="_blank" rel="noopener">Java读源码之Netty深入剖析</a></li><li><a href="https://github.com/wangweiX/myBooks/blob/master/computer/netty/Netty%20in%20Action.epub" target="_blank" rel="noopener">《Netty in action》</a></li><li><a href="https://www.jianshu.com/p/6efa9c5fa702" target="_blank" rel="noopener">https://www.jianshu.com/p/6efa9c5fa702</a></li><li><a href="https://juejin.im/post/5bda4cc55188257f630dac07" target="_blank" rel="noopener">https://juejin.im/post/5bda4cc55188257f630dac07</a></li></ul></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>请我喝杯咖啡吧~</div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>Donate</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="https://img.i7years.com/pay2Wechat.png" alt="王维 / Michael  Wang WeChat Pay"><p>WeChat Pay</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="https://img.i7years.com/pay2Alipay.png" alt="王维 / Michael  Wang Alipay"><p>Alipay</p></div><div id="bitcoin" style="display:inline-block"><img id="bitcoin_qr" src="https://img.i7years.com/wallet/rec_bitcoin.png" alt="王维 / Michael  Wang Bitcoin"><p>Bitcoin</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author:</strong> 王维 / Michael Wang</li><li class="post-copyright-link"><strong>Post link:</strong> <a href="https://wangwei.one/posts/netty-pipeline-source-analyse-1.html" title="Netty Pipeline源码分析(1)">https://wangwei.one/posts/netty-pipeline-source-analyse-1.html</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Netty/" rel="tag"># Netty</a></div><div class="post-widgets"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/netty-nioeventloop-analyse-for-startup.html" rel="next" title="Netty NioEventLoop 启动过程源码分析"><i class="fa fa-chevron-left"></i> Netty NioEventLoop 启动过程源码分析</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/netty-pipeline-source-analyse-2.html" rel="prev" title="Netty Pipeline源码分析(2)">Netty Pipeline源码分析(2) <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="https://img.i7years.com/avatar/naruto.jpg" alt="王维 / Michael  Wang"><p class="site-author-name" itemprop="name">王维 / Michael Wang</p><p class="site-description motion-element" itemprop="description">分享自己所思所学所行</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">62</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">37</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/wangweiX" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://medium.com/@wangwei_hz" target="_blank" title="Medium"><i class="fa fa-fw fa-medium"></i>Medium</a> </span><span class="links-of-author-item"><a href="https://twitter.com/wangwei_hz" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i>Twitter</a> </span><span class="links-of-author-item"><a href="mailto:w7years@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://learnblockchain.cn/" title="深入浅出区块链" target="_blank">深入浅出区块链</a></li><li class="links-of-blogroll-item"><a href="http://www.ruanyifeng.com/" title="阮一峰" target="_blank">阮一峰</a></li><li class="links-of-blogroll-item"><a href="https://tech.meituan.com/" title="美团点评" target="_blank">美团点评</a></li><li class="links-of-blogroll-item"><a href="https://daimajia.com/" title="代码家" target="_blank">代码家</a></li><li class="links-of-blogroll-item"><a href="https://halfrost.com/" title="霜" target="_blank">霜</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty-channel-lifecycle"><span class="nav-number">1.1.</span> <span class="nav-text">Netty channel lifecycle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty-channelHandler"><span class="nav-number">1.2.</span> <span class="nav-text">Netty channelHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty-ChannelPipeline"><span class="nav-number">1.3.</span> <span class="nav-text">Netty ChannelPipeline</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pipeline-UML"><span class="nav-number">2.</span> <span class="nav-text">Pipeline UML</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pipeline初始化"><span class="nav-number">3.</span> <span class="nav-text">Pipeline初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ChannelHandlerContext"><span class="nav-number">3.1.</span> <span class="nav-text">ChannelHandlerContext</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ChannelHandlerContext接口"><span class="nav-number">3.1.1.</span> <span class="nav-text">ChannelHandlerContext接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AttributeMap接口"><span class="nav-number">3.1.2.</span> <span class="nav-text">AttributeMap接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ChannelInboundInvoker接口"><span class="nav-number">3.1.3.</span> <span class="nav-text">ChannelInboundInvoker接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ChannelOutboundInvoker接口"><span class="nav-number">3.1.4.</span> <span class="nav-text">ChannelOutboundInvoker接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TailContext-amp-HeadContext"><span class="nav-number">3.2.</span> <span class="nav-text">TailContext &amp; HeadContext</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TailContext节点"><span class="nav-number">3.2.1.</span> <span class="nav-text">TailContext节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AbstractChannelHandlerContext"><span class="nav-number">3.2.2.</span> <span class="nav-text">AbstractChannelHandlerContext</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DefaultChannelHandlerContext"><span class="nav-number">3.2.3.</span> <span class="nav-text">DefaultChannelHandlerContext</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HeadContext"><span class="nav-number">3.2.4.</span> <span class="nav-text">HeadContext</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pipeline-节点添加"><span class="nav-number">4.</span> <span class="nav-text">Pipeline 节点添加</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ChannelInitializer"><span class="nav-number">4.1.</span> <span class="nav-text">ChannelInitializer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pipeline-节点删除"><span class="nav-number">5.</span> <span class="nav-text">Pipeline 节点删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">6.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">7.</span> <span class="nav-text">参考资料</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">王维 / Michael Wang</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">135.4k</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>var _mtac={};!function(){var t=document.createElement("script");t.src="https://pingjs.qq.com/h5/stats.js?v2.0.4",t.setAttribute("name","MTAH5"),t.setAttribute("sid","500547962");var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><div style="display:none"><script src="//s95.cnzz.com/z_stat.php?id=1270083794&web_id=1270083794" language="JavaScript"></script></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="https://static.i7years.com/blog/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="https://static.i7years.com/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="https://static.i7years.com/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="https://static.i7years.com/blog/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="https://static.i7years.com/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="https://static.i7years.com/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="https://static.i7years.com/blog/lib/canvas-nest/js/particles.min.js"></script><script type="text/javascript" src="https://static.i7years.com/blog/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="https://static.i7years.com/blog/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="https://static.i7years.com/blog/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="https://static.i7years.com/blog/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="https://static.i7years.com/blog/js/src/bootstrap.js?v=5.1.3"></script><script id="dsq-count-scr" src="https://techi7years.disqus.com/count.js" async></script><script type="text/javascript">var disqus_config=function(){this.page.url="https://wangwei.one/posts/netty-pipeline-source-analyse-1.html",this.page.identifier="posts/netty-pipeline-source-analyse-1.html",this.page.title="Netty Pipeline源码分析(1)"},d=document,s=d.createElement("script");s.src="https://techi7years.disqus.com/embed.js",s.setAttribute("data-timestamp",""+ +new Date),(d.head||d.body).appendChild(s)</script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">var isfetched=!1;var isXml=!0;var search_path="search.xml";if(search_path.length===0){search_path="search.xml"}else if(/json$/i.test(search_path)){isXml=!1}
    var path="/"+search_path;var onPopupClose=function(e){$('.popup').hide();$('#local-search-input').val('');$('.search-result-list').remove();$('#no-result').remove();$(".local-search-pop-overlay").remove();$('body').css('overflow','')}
    function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css('overflow','hidden');$('.search-popup-overlay').click(onPopupClose);$('.popup').toggle();var $localSearchInput=$('#local-search-input');$localSearchInput.attr("autocapitalize","none");$localSearchInput.attr("autocorrect","off");$localSearchInput.focus()}
    var searchFunc=function(path,search_id,content_id){'use strict';$("body").append('<div class="search-popup-overlay local-search-pop-overlay">'+'<div id="search-loading-icon">'+'<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>'+'</div>'+'</div>').css('overflow','hidden');$("#search-loading-icon").css('margin','20% auto 0 auto').css('text-align','center');$.ajax({url:path,dataType:isXml?"xml":"json",async:!0,success:function(res){isfetched=!0;$('.popup').detach().appendTo('.header-inner');var datas=isXml?$("entry",res).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():res;var input=document.getElementById(search_id);var resultContent=document.getElementById(content_id);var inputEventFunction=function(){var searchText=input.value.trim().toLowerCase();var keywords=searchText.split(/[\s\-]+/);if(keywords.length>1){keywords.push(searchText)}
    var resultItems=[];if(searchText.length>0){datas.forEach(function(data){var isMatch=!1;var hitCount=0;var searchTextCount=0;var title=data.title.trim();var titleInLowerCase=title.toLowerCase();var content=data.content.trim().replace(/<[^>]+>/g,"");var contentInLowerCase=content.toLowerCase();var articleUrl=decodeURIComponent(data.url);var indexOfTitle=[];var indexOfContent=[];if(title!=''){keywords.forEach(function(keyword){function getIndexByWord(word,text,caseSensitive){var wordLen=word.length;if(wordLen===0){return[]}
    var startPosition=0,position=[],index=[];if(!caseSensitive){text=text.toLowerCase();word=word.toLowerCase()}
    while((position=text.indexOf(word,startPosition))>-1){index.push({position:position,word:word});startPosition=position+wordLen}
    return index}
    indexOfTitle=indexOfTitle.concat(getIndexByWord(keyword,titleInLowerCase,!1));indexOfContent=indexOfContent.concat(getIndexByWord(keyword,contentInLowerCase,!1))});if(indexOfTitle.length>0||indexOfContent.length>0){isMatch=!0;hitCount=indexOfTitle.length+indexOfContent.length}}
    if(isMatch){[indexOfTitle,indexOfContent].forEach(function(index){index.sort(function(itemLeft,itemRight){if(itemRight.position!==itemLeft.position){return itemRight.position-itemLeft.position}else{return itemLeft.word.length-itemRight.word.length}})});function mergeIntoSlice(text,start,end,index){var item=index[index.length-1];var position=item.position;var word=item.word;var hits=[];var searchTextCountInSlice=0;while(position+word.length<=end&&index.length!=0){if(word===searchText){searchTextCountInSlice++}
    hits.push({position:position,length:word.length});var wordEnd=position+word.length;index.pop();while(index.length!=0){item=index[index.length-1];position=item.position;word=item.word;if(wordEnd>position){index.pop()}else{break}}}
    searchTextCount+=searchTextCountInSlice;return{hits:hits,start:start,end:end,searchTextCount:searchTextCountInSlice}}
    var slicesOfTitle=[];if(indexOfTitle.length!=0){slicesOfTitle.push(mergeIntoSlice(title,0,title.length,indexOfTitle))}
    var slicesOfContent=[];while(indexOfContent.length!=0){var item=indexOfContent[indexOfContent.length-1];var position=item.position;var word=item.word;var start=position-20;var end=position+80;if(start<0){start=0}
    if(end<position+word.length){end=position+word.length}
    if(end>content.length){end=content.length}
    slicesOfContent.push(mergeIntoSlice(content,start,end,indexOfContent))}
    slicesOfContent.sort(function(sliceLeft,sliceRight){if(sliceLeft.searchTextCount!==sliceRight.searchTextCount){return sliceRight.searchTextCount-sliceLeft.searchTextCount}else if(sliceLeft.hits.length!==sliceRight.hits.length){return sliceRight.hits.length-sliceLeft.hits.length}else{return sliceLeft.start-sliceRight.start}});var upperBound=parseInt('1');if(upperBound>=0){slicesOfContent=slicesOfContent.slice(0,upperBound)}
    function highlightKeyword(text,slice){var result='';var prevEnd=slice.start;slice.hits.forEach(function(hit){result+=text.substring(prevEnd,hit.position);var end=hit.position+hit.length;result+='<b class="search-keyword">'+text.substring(hit.position,end)+'</b>';prevEnd=end});result+=text.substring(prevEnd,slice.end);return result}
    var resultItem='';if(slicesOfTitle.length!=0){resultItem+="<li><a href='"+articleUrl+"' class='search-result-title'>"+highlightKeyword(title,slicesOfTitle[0])+"</a>"}else{resultItem+="<li><a href='"+articleUrl+"' class='search-result-title'>"+title+"</a>"}
    slicesOfContent.forEach(function(slice){resultItem+="<a href='"+articleUrl+"'>"+"<p class=\"search-result\">"+highlightKeyword(content,slice)+"...</p>"+"</a>"});resultItem+="</li>";resultItems.push({item:resultItem,searchTextCount:searchTextCount,hitCount:hitCount,id:resultItems.length})}})};if(keywords.length===1&&keywords[0]===""){resultContent.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'}else if(resultItems.length===0){resultContent.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'}else{resultItems.sort(function(resultLeft,resultRight){if(resultLeft.searchTextCount!==resultRight.searchTextCount){return resultRight.searchTextCount-resultLeft.searchTextCount}else if(resultLeft.hitCount!==resultRight.hitCount){return resultRight.hitCount-resultLeft.hitCount}else{return resultRight.id-resultLeft.id}});var searchResultList='<ul class=\"search-result-list\">';resultItems.forEach(function(result){searchResultList+=result.item})
    searchResultList+="</ul>";resultContent.innerHTML=searchResultList}}
    if('auto'==='auto'){input.addEventListener('input',inputEventFunction)}else{$('.search-icon').click(inputEventFunction);input.addEventListener('keypress',function(event){if(event.keyCode===13){inputEventFunction()}})}
    $(".local-search-pop-overlay").remove();$('body').css('overflow','');proceedsearch()}})}
    $('.popup-trigger').click(function(e){e.stopPropagation();if(isfetched===!1){searchFunc(path,'local-search-input','local-search-result')}else{proceedsearch()}});$('.popup-btn-close').click(onPopupClose);$('.popup').click(function(e){e.stopPropagation()});$(document).on('keyup',function(event){var shouldDismissSearchPopup=event.which===27&&$('.search-popup').is(':visible');if(shouldDismissSearchPopup){onPopupClose()}})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><link rel="stylesheet" href="https://static.i7years.com/blog/lib/needsharebutton/needsharebutton.min.css?v=1544067396031"><script type="text/javascript" src="https://static.i7years.com/blog/lib/needsharebutton/needsharebutton.min.js?v=1544067396031"></script><script>pbOptions={iconStyle:"default",boxForm:"horizontal",position:"topRight",networks:"Wechat,Weibo,QQZone,Twitter,Facebook,Linkedin,Evernote,Douban,Reddit,Mailto"},new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={iconStyle:"default",boxForm:"horizontal",position:"middleRight",networks:"Wechat,Weibo,QQZone,Twitter,Facebook,Linkedin,Evernote,Douban,Reddit,Mailto"},new needShareButton("#needsharebutton-float",flOptions)</script></body></html>